var global = Function("return this;")();
/*jshint strict:true node:true es5:true onevar:true laxcomma:true laxbreak:true eqeqeq:true immed:true latedef:true*/
(function () {
  "use strict";

  var oldRequire = require
    , modules = {}
    ;

  function newRequire(modulename) {
    var err
      , mod
      , metamod
      ;

    try {
      mod = oldRequire(modulename);
    } catch(e) {
      err = e;
    }

    if (mod) {
      return mod;
    }

    metamod = modules[modulename];
    
    if (metamod) {
      mod = metamod();
      return mod;
    }

    // make it possible to require 'process', etc
    mod = global[modulename];

    if (mod) {
      return mod;
    }

    console.error(modulename);
    throw err;
  }

  function provide(modulename, factory) {
    var modReal
      ;

    function metamod() {
      if (modReal) {
        return modReal;
      }

      if (!factory.__pakmanager_factory__) {
        modReal = factory;
        return factory;
      }

      if (factory.__factoryIsResolving) {
        console.error('Your circular dependencies are too powerful!');
        return factory.__moduleExports;
      }

      factory.__factoryIsResolving = true;
      factory.__moduleExports = {};
      modReal = factory(factory.__moduleExports);
      factory.__factoryIsResolving = false;

      return modReal;
    }

    modules[modulename] = metamod;
    // somewhat of a dirty hack since I don't have a plug for loading the "main" module otherwise
    modules['pakmanager.main'] = metamod;
  }

  require = newRequire;
  global.require = newRequire;
  global.provide = provide;
}());

// pakmanager:csv-generate
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Generated by CoffeeScript 1.7.1
    var Generator, stream, util;
    
    stream = require('stream');
    
    util = require('util');
    
    module.exports = function() {
      var callback, data, generator, options;
      if (arguments.length === 2) {
        options = arguments[0];
        callback = arguments[1];
      } else if (arguments.length === 1) {
        if (typeof arguments[0] === 'function') {
          options = {};
          callback = arguments[0];
        } else {
          options = arguments[0];
        }
      } else if (arguments.length === 0) {
        options = {};
      }
      generator = new Generator(options);
      if (callback) {
        data = [];
        generator.on('readable', function() {
          var d, _results;
          _results = [];
          while (d = generator.read()) {
            _results.push(data.push(options.objectMode ? d : d.toString()));
          }
          return _results;
        });
        generator.on('error', callback);
        generator.on('end', function() {
          return callback(null, options.objectMode ? data : data.join(''));
        });
      }
      return generator;
    };
    
    Generator = function(options) {
      var i, v, _base, _base1, _base2, _base3, _base4, _base5, _base6, _base7, _base8, _i, _len, _ref;
      this.options = options != null ? options : {};
      stream.Readable.call(this, this.options);
      this.options.count = 0;
      if ((_base = this.options).duration == null) {
        _base.duration = 4 * 60 * 1000;
      }
      if ((_base1 = this.options).columns == null) {
        _base1.columns = 8;
      }
      if ((_base2 = this.options).max_word_length == null) {
        _base2.max_word_length = 16;
      }
      if ((_base3 = this.options).fixed_size == null) {
        _base3.fixed_size = false;
      }
      if (this.fixed_size_buffer == null) {
        this.fixed_size_buffer = '';
      }
      if ((_base4 = this.options).start == null) {
        _base4.start = Date.now();
      }
      if ((_base5 = this.options).end == null) {
        _base5.end = null;
      }
      if ((_base6 = this.options).seed == null) {
        _base6.seed = false;
      }
      if ((_base7 = this.options).length == null) {
        _base7.length = -1;
      }
      if ((_base8 = this.options).delimiter == null) {
        _base8.delimiter = ',';
      }
      this.count_written = 0;
      this.count_created = 0;
      if (typeof this.options.columns === 'number') {
        this.options.columns = new Array(this.options.columns);
      }
      _ref = this.options.columns;
      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
        v = _ref[i];
        if (v == null) {
          v = 'ascii';
        }
        if (typeof v === 'string') {
          this.options.columns[i] = Generator[v];
        }
      }
      return this;
    };
    
    util.inherits(Generator, stream.Readable);
    
    module.exports.Generator = Generator;
    
    Generator.prototype.random = function() {
      if (this.options.seed) {
        return this.options.seed = this.options.seed * Math.PI * 100 % 100 / 100;
      } else {
        return Math.random();
      }
    };
    
    Generator.prototype.end = function() {
      return this.push(null);
    };
    
    Generator.prototype._read = function(size) {
      var column, data, header, length, line, lineLength, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref;
      data = [];
      length = this.fixed_size_buffer.length;
      if (length) {
        data.push(this.fixed_size_buffer);
      }
      while (true) {
        if ((this.count_created === this.options.length) || (this.options.end && Date.now() > this.options.end)) {
          if (data.length) {
            if (this.options.objectMode) {
              for (_i = 0, _len = data.length; _i < _len; _i++) {
                line = data[_i];
                this.count_written++;
                this.push(line);
              }
            } else {
              this.count_written++;
              this.push(data.join(''));
            }
          }
          return this.push(null);
        }
        line = [];
        _ref = this.options.columns;
        for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
          header = _ref[_j];
          line.push("" + (header(this)));
        }
        if (this.options.objectMode) {
          lineLength = 0;
          for (_k = 0, _len2 = line.length; _k < _len2; _k++) {
            column = line[_k];
            lineLength += column.length;
          }
        } else {
          line = "" + (this.count_created === 0 ? '' : '\n') + (line.join(this.options.delimiter));
          lineLength = line.length;
        }
        this.count_created++;
        if (length + lineLength > size) {
          if (this.options.objectMode) {
            data.push(line);
            for (_l = 0, _len3 = data.length; _l < _len3; _l++) {
              line = data[_l];
              this.count_written++;
              this.push(line);
            }
          } else {
            if (this.options.fixed_size) {
              this.fixed_size_buffer = line.substr(size - length);
              data.push(line.substr(0, size - length));
            } else {
              data.push(line);
            }
            this.count_written++;
            this.push(data.join(''));
          }
          break;
        }
        length += lineLength;
        data.push(line);
      }
    };
    
    Generator.ascii = function(gen) {
      var char, column, nb_chars, _i, _ref;
      column = [];
      for (nb_chars = _i = 0, _ref = Math.ceil(gen.random() * gen.options.max_word_length); 0 <= _ref ? _i < _ref : _i > _ref; nb_chars = 0 <= _ref ? ++_i : --_i) {
        char = Math.floor(gen.random() * 32);
        column.push(String.fromCharCode(char + (char < 16 ? 65 : 97 - 16)));
      }
      return column.join('');
    };
    
    Generator.int = function(gen) {
      return Math.floor(gen.random() * Math.pow(2, 52));
    };
    
    Generator.bool = function(gen) {
      return Math.floor(gen.random() * 2);
    };
    
  provide("csv-generate", module.exports);
}(global));

// pakmanager:csv-parse
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Generated by CoffeeScript 1.9.1
    var Parser, StringDecoder, stream, util;
    
    stream = require('stream');
    
    util = require('util');
    
    StringDecoder = require('string_decoder').StringDecoder;
    
    module.exports = function() {
      var callback, called, chunks, data, options, parser;
      if (arguments.length === 3) {
        data = arguments[0];
        options = arguments[1];
        callback = arguments[2];
        if (typeof callback !== 'function') {
          throw Error("Invalid callback argument: " + (JSON.stringify(callback)));
        }
        if (typeof data !== 'string') {
          return callback(Error("Invalid data argument: " + (JSON.stringify(data))));
        }
      } else if (arguments.length === 2) {
        if (typeof arguments[0] === 'string' || Buffer.isBuffer(arguments[0])) {
          data = arguments[0];
        } else {
          options = arguments[0];
        }
        if (typeof arguments[1] === 'function') {
          callback = arguments[1];
        } else {
          options = arguments[1];
        }
      } else if (arguments.length === 1) {
        if (typeof arguments[0] === 'function') {
          callback = arguments[0];
        } else {
          options = arguments[0];
        }
      }
      if (options == null) {
        options = {};
      }
      parser = new Parser(options);
      if (data) {
        process.nextTick(function() {
          parser.write(data);
          return parser.end();
        });
      }
      if (callback) {
        called = false;
        chunks = options.objname ? {} : [];
        parser.on('readable', function() {
          var chunk, results;
          results = [];
          while (chunk = parser.read()) {
            if (options.objname) {
              results.push(chunks[chunk[0]] = chunk[1]);
            } else {
              results.push(chunks.push(chunk));
            }
          }
          return results;
        });
        parser.on('error', function(err) {
          called = true;
          return callback(err);
        });
        parser.on('end', function() {
          if (!called) {
            return callback(null, chunks);
          }
        });
      }
      return parser;
    };
    
    Parser = function(options) {
      var base, base1, base10, base11, base2, base3, base4, base5, base6, base7, base8, base9, k, v;
      if (options == null) {
        options = {};
      }
      options.objectMode = true;
      this.options = {};
      for (k in options) {
        v = options[k];
        this.options[k] = v;
      }
      stream.Transform.call(this, this.options);
      if ((base = this.options).rowDelimiter == null) {
        base.rowDelimiter = null;
      }
      if ((base1 = this.options).delimiter == null) {
        base1.delimiter = ',';
      }
      if ((base2 = this.options).quote == null) {
        base2.quote = '"';
      }
      if ((base3 = this.options).escape == null) {
        base3.escape = '"';
      }
      if ((base4 = this.options).columns == null) {
        base4.columns = null;
      }
      if ((base5 = this.options).comment == null) {
        base5.comment = '';
      }
      if ((base6 = this.options).objname == null) {
        base6.objname = false;
      }
      if ((base7 = this.options).trim == null) {
        base7.trim = false;
      }
      if ((base8 = this.options).ltrim == null) {
        base8.ltrim = false;
      }
      if ((base9 = this.options).rtrim == null) {
        base9.rtrim = false;
      }
      if ((base10 = this.options).auto_parse == null) {
        base10.auto_parse = false;
      }
      if ((base11 = this.options).skip_empty_lines == null) {
        base11.skip_empty_lines = false;
      }
      this.lines = 0;
      this.count = 0;
      this.regexp_int = /^(\-|\+)?([1-9]+[0-9]*)$/;
      this.regexp_float = /^(\-|\+)?([0-9]+(\.[0-9]+)?([eE][0-9]+)?|Infinity)$/;
      this.decoder = new StringDecoder();
      this.buf = '';
      this.quoting = false;
      this.commenting = false;
      this.field = '';
      this.nextChar = null;
      this.closingQuote = 0;
      this.line = [];
      this.chunks = [];
      return this;
    };
    
    util.inherits(Parser, stream.Transform);
    
    module.exports.Parser = Parser;
    
    Parser.prototype._transform = function(chunk, encoding, callback) {
      var err;
      if (chunk instanceof Buffer) {
        chunk = this.decoder.write(chunk);
      }
      try {
        this.__write(chunk, false);
        return callback();
      } catch (_error) {
        err = _error;
        return this.emit('error', err);
      }
    };
    
    Parser.prototype._flush = function(callback) {
      var err;
      try {
        this.__write(this.decoder.end(), true);
        if (this.quoting) {
          this.emit('error', new Error("Quoted field not terminated at line " + (this.lines + 1)));
          return;
        }
        if (this.line.length > 0) {
          this.__push(this.line);
        }
        return callback();
      } catch (_error) {
        err = _error;
        return this.emit('error', err);
      }
    };
    
    Parser.prototype.__push = function(line) {
      var field, i, j, len, lineAsColumns;
      if (this.options.columns === true) {
        this.options.columns = line;
        return;
      } else if (typeof this.options.columns === 'function') {
        this.options.columns = this.options.columns(line);
        return;
      }
      this.count++;
      if (this.options.columns != null) {
        lineAsColumns = {};
        for (i = j = 0, len = line.length; j < len; i = ++j) {
          field = line[i];
          lineAsColumns[this.options.columns[i]] = field;
        }
        if (this.options.objname) {
          return this.push([lineAsColumns[this.options.objname], lineAsColumns]);
        } else {
          return this.push(lineAsColumns);
        }
      } else {
        return this.push(line);
      }
    };
    
    Parser.prototype.__write = function(chars, end, callback) {
      var acceptedLength, areNextCharsDelimiter, areNextCharsRowDelimiters, char, escapeIsQuote, i, isDelimiter, isEscape, isNextCharAComment, isQuote, isRowDelimiter, l, ltrim, nextCharPos, ref, results, rowDelimiter, rowDelimiterLength, rtrim, wasCommenting;
      ltrim = this.options.trim || this.options.ltrim;
      rtrim = this.options.trim || this.options.rtrim;
      chars = this.buf + chars;
      l = chars.length;
      rowDelimiterLength = this.options.rowDelimiter ? this.options.rowDelimiter.length : 0;
      i = 0;
      if (this.lines === 0 && 0xFEFF === chars.charCodeAt(0)) {
        i++;
      }
      while (i < l) {
        acceptedLength = rowDelimiterLength + this.options.comment.length + this.options.escape.length + this.options.delimiter.length;
        if (this.quoting) {
          acceptedLength += this.options.quote.length;
        }
        if (!end && (i + acceptedLength >= l)) {
          break;
        }
        char = this.nextChar ? this.nextChar : chars.charAt(i);
        this.nextChar = chars.charAt(i + 1);
        if (this.options.rowDelimiter == null) {
          if ((this.field === '') && (char === '\n' || char === '\r')) {
            rowDelimiter = char;
            nextCharPos = i + 1;
          } else if (this.nextChar === '\n' || this.nextChar === '\r') {
            rowDelimiter = this.nextChar;
            nextCharPos = i + 2;
          }
          if (rowDelimiter) {
            if (rowDelimiter === '\r' && chars.charAt(nextCharPos) === '\n') {
              rowDelimiter += '\n';
            }
            this.options.rowDelimiter = rowDelimiter;
            rowDelimiterLength = this.options.rowDelimiter.length;
          }
        }
        if (!this.commenting && char === this.options.escape) {
          escapeIsQuote = this.options.escape === this.options.quote;
          isEscape = this.nextChar === this.options.escape;
          isQuote = this.nextChar === this.options.quote;
          if (!(escapeIsQuote && !this.field && !this.quoting) && (isEscape || isQuote)) {
            i++;
            char = this.nextChar;
            this.nextChar = chars.charAt(i + 1);
            this.field += char;
            i++;
            continue;
          }
        }
        if (!this.commenting && char === this.options.quote) {
          if (this.quoting) {
            areNextCharsRowDelimiters = this.options.rowDelimiter && chars.substr(i + 1, this.options.rowDelimiter.length) === this.options.rowDelimiter;
            areNextCharsDelimiter = chars.substr(i + 1, this.options.delimiter.length) === this.options.delimiter;
            isNextCharAComment = this.nextChar === this.options.comment;
            if (this.nextChar && !areNextCharsRowDelimiters && !areNextCharsDelimiter && !isNextCharAComment) {
              if (this.options.relax) {
                this.quoting = false;
                this.field = "" + this.options.quote + this.field;
              } else {
                throw Error("Invalid closing quote at line " + (this.lines + 1) + "; found " + (JSON.stringify(this.nextChar)) + " instead of delimiter " + (JSON.stringify(this.options.delimiter)));
              }
            } else {
              this.quoting = false;
              this.closingQuote = this.options.quote.length;
              i++;
              if (end && i === l) {
                this.line.push(this.field);
              }
              continue;
            }
          } else if (!this.field) {
            this.quoting = true;
            i++;
            continue;
          } else if (this.field && !this.options.relax) {
            throw Error("Invalid opening quote at line " + (this.lines + 1));
          }
        }
        isRowDelimiter = this.options.rowDelimiter && chars.substr(i, this.options.rowDelimiter.length) === this.options.rowDelimiter;
        if (isRowDelimiter) {
          this.lines++;
        }
        wasCommenting = false;
        if (!this.commenting && !this.quoting && this.options.comment && chars.substr(i, this.options.comment.length) === this.options.comment) {
          this.commenting = true;
        } else if (this.commenting && isRowDelimiter) {
          wasCommenting = true;
          this.commenting = false;
        }
        isDelimiter = chars.substr(i, this.options.delimiter.length) === this.options.delimiter;
        if (!this.commenting && !this.quoting && (isDelimiter || isRowDelimiter)) {
          if (isRowDelimiter && this.line.length === 0 && this.field === '') {
            if (wasCommenting || this.options.skip_empty_lines) {
              i += this.options.rowDelimiter.length;
              this.nextChar = chars.charAt(i);
              continue;
            }
          }
          if (rtrim) {
            if (!this.closingQuote) {
              this.field = this.field.trimRight();
            }
          }
          if (this.options.auto_parse && this.regexp_int.test(this.field)) {
            this.line.push(parseInt(this.field));
          } else if (this.options.auto_parse && this.regexp_float.test(this.field)) {
            this.line.push(parseFloat(this.field));
          } else {
            this.line.push(this.field);
          }
          this.closingQuote = 0;
          this.field = '';
          if (isDelimiter) {
            i += this.options.delimiter.length;
            this.nextChar = chars.charAt(i);
            if (end && !this.nextChar) {
              isRowDelimiter = true;
              this.line.push('');
            }
          }
          if (isRowDelimiter) {
            this.__push(this.line);
            this.line = [];
            i += (ref = this.options.rowDelimiter) != null ? ref.length : void 0;
            this.nextChar = chars.charAt(i);
            continue;
          }
        } else if (!this.commenting && !this.quoting && (char === ' ' || char === '\t')) {
          if (!(ltrim && !this.field)) {
            this.field += char;
          }
          if (end && i + 1 === l) {
            if (this.options.trim || this.options.rtrim) {
              this.field = this.field.trimRight();
            }
            this.line.push(this.field);
          }
          i++;
        } else if (!this.commenting) {
          this.field += char;
          i++;
          if (end && i === l) {
            this.line.push(this.field);
          }
        } else {
          i++;
        }
      }
      this.buf = '';
      results = [];
      while (i < l) {
        this.buf += chars.charAt(i);
        results.push(i++);
      }
      return results;
    };
    
  provide("csv-parse", module.exports);
}(global));

// pakmanager:stream-transform
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Generated by CoffeeScript 1.9.2
    var Transformer, stream, util,
      slice = [].slice;
    
    stream = require('stream');
    
    util = require('util');
    
    module.exports = function() {
      var argument, callback, data, error, handler, i, j, k, len, options, result, transform, type, v;
      options = {};
      for (i = j = 0, len = arguments.length; j < len; i = ++j) {
        argument = arguments[i];
        type = typeof argument;
        if (argument === null) {
          type = 'null';
        } else if (type === 'object' && Array.isArray(argument)) {
          type = 'array';
        }
        if (i === 0) {
          if (type === 'function') {
            handler = argument;
          } else if (type !== null) {
            data = argument;
          }
          continue;
        }
        if (type === 'object') {
          for (k in argument) {
            v = argument[k];
            options[k] = v;
          }
        } else if (type === 'function') {
          if (handler && i === arguments.length - 1) {
            callback = argument;
          } else {
            handler = argument;
          }
        } else if (type !== 'null') {
          throw new Error('Invalid arguments');
        }
      }
      transform = new Transformer(options, handler);
      error = false;
      if (data) {
        process.nextTick(function() {
          var l, len1, row;
          for (l = 0, len1 = data.length; l < len1; l++) {
            row = data[l];
            if (error) {
              break;
            }
            transform.write(row);
          }
          return transform.end();
        });
      }
      if (callback) {
        result = [];
        transform.on('readable', function() {
          var r, results;
          results = [];
          while ((r = transform.read())) {
            results.push(result.push(r));
          }
          return results;
        });
        transform.on('error', function(err) {
          error = true;
          return callback(err);
        });
        transform.on('end', function() {
          if (!error) {
            return callback(null, result);
          }
        });
      }
      return transform;
    };
    
    Transformer = function(options1, transform1) {
      var base;
      this.options = options1 != null ? options1 : {};
      this.transform = transform1;
      this.options.objectMode = true;
      if ((base = this.options).parallel == null) {
        base.parallel = 100;
      }
      stream.Transform.call(this, this.options);
      this.running = 0;
      this.started = 0;
      this.finished = 0;
      return this;
    };
    
    util.inherits(Transformer, stream.Transform);
    
    module.exports.Transformer = Transformer;
    
    Transformer.prototype._transform = function(chunk, encoding, cb) {
      var err;
      this.started++;
      this.running++;
      if (this.running < this.options.parallel) {
        cb();
        cb = null;
      }
      try {
        if (this.transform.length === 2) {
          this.transform.call(null, chunk, (function(_this) {
            return function() {
              var chunks, err;
              err = arguments[0], chunks = 2 <= arguments.length ? slice.call(arguments, 1) : [];
              return _this._done(err, chunks, cb);
            };
          })(this));
        } else {
          this._done(null, [this.transform.call(null, chunk)], cb);
        }
        return false;
      } catch (_error) {
        err = _error;
        return this._done(err);
      }
    };
    
    Transformer.prototype._flush = function(cb) {
      this._ending = function() {
        if (this.running === 0) {
          return cb();
        }
      };
      return this._ending();
    };
    
    Transformer.prototype._done = function(err, chunks, cb) {
      var chunk, j, len;
      this.running--;
      if (err) {
        return this.emit('error', err);
      }
      this.finished++;
      for (j = 0, len = chunks.length; j < len; j++) {
        chunk = chunks[j];
        if (typeof chunk === 'number') {
          chunk = "" + chunk;
        }
        if (chunk != null) {
          this.push(chunk);
        }
      }
      if (cb) {
        cb();
      }
      if (this._ending) {
        return this._ending();
      }
    };
    
  provide("stream-transform", module.exports);
}(global));

// pakmanager:csv-stringify
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Generated by CoffeeScript 1.9.2
    var Stringifier, stream, util;
    
    stream = require('stream');
    
    util = require('util');
    
    module.exports = function() {
      var callback, chunks, data, options, stringifier;
      if (arguments.length === 3) {
        data = arguments[0];
        options = arguments[1];
        callback = arguments[2];
      } else if (arguments.length === 2) {
        if (Array.isArray(arguments[0])) {
          data = arguments[0];
        } else {
          options = arguments[0];
        }
        if (typeof arguments[1] === 'function') {
          callback = arguments[1];
        } else {
          options = arguments[1];
        }
      } else if (arguments.length === 1) {
        if (typeof arguments[0] === 'function') {
          callback = arguments[0];
        } else if (Array.isArray(arguments[0])) {
          data = arguments[0];
        } else {
          options = arguments[0];
        }
      }
      if (options == null) {
        options = {};
      }
      stringifier = new Stringifier(options);
      if (data) {
        process.nextTick(function() {
          var d, j, len;
          for (j = 0, len = data.length; j < len; j++) {
            d = data[j];
            stringifier.write(d);
          }
          return stringifier.end();
        });
      }
      if (callback) {
        chunks = [];
        stringifier.on('readable', function() {
          var chunk, results;
          results = [];
          while (chunk = stringifier.read()) {
            results.push(chunks.push(chunk));
          }
          return results;
        });
        stringifier.on('error', function(err) {
          return callback(err);
        });
        stringifier.on('end', function() {
          return callback(null, chunks.join(''));
        });
      }
      return stringifier;
    };
    
    Stringifier = function(options) {
      var base, base1, base2, base3, base4, base5, base6, base7, base8;
      if (options == null) {
        options = {};
      }
      stream.Transform.call(this, options);
      this.options = options;
      if ((base = this.options).delimiter == null) {
        base.delimiter = ',';
      }
      if ((base1 = this.options).quote == null) {
        base1.quote = '"';
      }
      if ((base2 = this.options).quoted == null) {
        base2.quoted = false;
      }
      if ((base3 = this.options).quotedString == null) {
        base3.quotedString = false;
      }
      if ((base4 = this.options).eof == null) {
        base4.eof = true;
      }
      if ((base5 = this.options).escape == null) {
        base5.escape = '"';
      }
      if ((base6 = this.options).columns == null) {
        base6.columns = null;
      }
      if ((base7 = this.options).header == null) {
        base7.header = false;
      }
      if ((base8 = this.options).rowDelimiter == null) {
        base8.rowDelimiter = '\n';
      }
      if (this.countWriten == null) {
        this.countWriten = 0;
      }
      switch (this.options.rowDelimiter) {
        case 'auto':
          this.options.rowDelimiter = null;
          break;
        case 'unix':
          this.options.rowDelimiter = "\n";
          break;
        case 'mac':
          this.options.rowDelimiter = "\r";
          break;
        case 'windows':
          this.options.rowDelimiter = "\r\n";
          break;
        case 'unicode':
          this.options.rowDelimiter = "\u2028";
      }
      return this;
    };
    
    util.inherits(Stringifier, stream.Transform);
    
    module.exports.Stringifier = Stringifier;
    
    Stringifier.prototype.headers = function() {
      var k, label, labels;
      if (!this.options.header) {
        return;
      }
      if (!this.options.columns) {
        return;
      }
      labels = this.options.columns;
      if (typeof labels === 'object') {
        labels = (function() {
          var results;
          results = [];
          for (k in labels) {
            label = labels[k];
            results.push(label);
          }
          return results;
        })();
      }
      if (this.options.eof) {
        labels = this.stringify(labels) + this.options.rowDelimiter;
      } else {
        labels = this.stringify(labels);
      }
      return stream.Transform.prototype.write.call(this, labels);
    };
    
    Stringifier.prototype.end = function(chunk, encoding, callback) {
      if (this.countWriten === 0) {
        this.headers();
      }
      return stream.Transform.prototype.end.apply(this, arguments);
    };
    
    Stringifier.prototype.write = function(chunk, encoding, callback) {
      var base, e, preserve;
      if (chunk == null) {
        return;
      }
      preserve = typeof chunk !== 'object';
      if (!preserve) {
        if (this.countWriten === 0 && !Array.isArray(chunk)) {
          if ((base = this.options).columns == null) {
            base.columns = Object.keys(chunk);
          }
        }
        try {
          this.emit('record', chunk, this.countWriten);
        } catch (_error) {
          e = _error;
          return this.emit('error', e);
        }
        if (this.options.eof) {
          chunk = this.stringify(chunk) + this.options.rowDelimiter;
        } else {
          chunk = this.stringify(chunk);
          if (this.options.header || this.countWriten) {
            chunk = this.options.rowDelimiter + chunk;
          }
        }
      }
      if (typeof chunk === 'number') {
        chunk = "" + chunk;
      }
      if (this.countWriten === 0) {
        this.headers();
      }
      if (!preserve) {
        this.countWriten++;
      }
      return stream.Transform.prototype.write.call(this, chunk, encoding, callback);
    };
    
    Stringifier.prototype._transform = function(chunk, encoding, callback) {
      this.push(chunk);
      return callback();
    };
    
    Stringifier.prototype.stringify = function(line) {
      var _line, column, columns, containsLinebreak, containsQuote, containsdelimiter, delimiter, escape, field, i, j, l, newLine, quote, ref, ref1, regexp;
      if (typeof line !== 'object') {
        return line;
      }
      columns = this.options.columns;
      if (typeof columns === 'object' && columns !== null && !Array.isArray(columns)) {
        columns = Object.keys(columns);
      }
      delimiter = this.options.delimiter;
      quote = this.options.quote;
      escape = this.options.escape;
      if (!Array.isArray(line)) {
        _line = [];
        if (columns) {
          for (i = j = 0, ref = columns.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
            column = columns[i];
            _line[i] = typeof line[column] === 'undefined' || line[column] === null ? '' : line[column];
          }
        } else {
          for (column in line) {
            _line.push(line[column]);
          }
        }
        line = _line;
        _line = null;
      } else if (columns) {
        line.splice(columns.length);
      }
      if (Array.isArray(line)) {
        newLine = '';
        for (i = l = 0, ref1 = line.length; 0 <= ref1 ? l < ref1 : l > ref1; i = 0 <= ref1 ? ++l : --l) {
          field = line[i];
          if (typeof field === 'string') {
    
          } else if (typeof field === 'number') {
            field = '' + field;
          } else if (typeof field === 'boolean') {
            field = field ? '1' : '';
          } else if (field instanceof Date) {
            field = '' + field.getTime();
          } else if (typeof field === 'object' && field !== null) {
            field = JSON.stringify(field);
          }
          if (field) {
            containsdelimiter = field.indexOf(delimiter) >= 0;
            containsQuote = field.indexOf(quote) >= 0;
            containsLinebreak = field.indexOf('\r') >= 0 || field.indexOf('\n') >= 0;
            if (containsQuote) {
              regexp = new RegExp(quote, 'g');
              field = field.replace(regexp, escape + quote);
            }
            if (containsQuote || containsdelimiter || containsLinebreak || this.options.quoted || (this.options.quotedString && typeof line[i] === 'string')) {
              field = quote + field + quote;
            }
            newLine += field;
          } else if (this.options.quotedEmpty || ((this.options.quotedEmpty == null) && line[i] === '' && this.options.quotedString)) {
            newLine += quote + quote;
          }
          if (i !== line.length - 1) {
            newLine += delimiter;
          }
        }
        line = newLine;
      }
      return line;
    };
    
  provide("csv-stringify", module.exports);
}(global));

// pakmanager:colors/lib/styles
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*
    The MIT License (MIT)
    
    Copyright (c) Sindre Sorhus <sindresorhus@gmail.com> (sindresorhus.com)
    
    Permission is hereby granted, free of charge, to any person obtaining a copy
    of this software and associated documentation files (the "Software"), to deal
    in the Software without restriction, including without limitation the rights
    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:
    
    The above copyright notice and this permission notice shall be included in
    all copies or substantial portions of the Software.
    
    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
    THE SOFTWARE.
    
    */
    
    var styles = {};
    module['exports'] = styles;
    
    var codes = {
      reset: [0, 0],
    
      bold: [1, 22],
      dim: [2, 22],
      italic: [3, 23],
      underline: [4, 24],
      inverse: [7, 27],
      hidden: [8, 28],
      strikethrough: [9, 29],
    
      black: [30, 39],
      red: [31, 39],
      green: [32, 39],
      yellow: [33, 39],
      blue: [34, 39],
      magenta: [35, 39],
      cyan: [36, 39],
      white: [37, 39],
      gray: [90, 39],
      grey: [90, 39],
    
      bgBlack: [40, 49],
      bgRed: [41, 49],
      bgGreen: [42, 49],
      bgYellow: [43, 49],
      bgBlue: [44, 49],
      bgMagenta: [45, 49],
      bgCyan: [46, 49],
      bgWhite: [47, 49],
    
      // legacy styles for colors pre v1.0.0
      blackBG: [40, 49],
      redBG: [41, 49],
      greenBG: [42, 49],
      yellowBG: [43, 49],
      blueBG: [44, 49],
      magentaBG: [45, 49],
      cyanBG: [46, 49],
      whiteBG: [47, 49]
    
    };
    
    Object.keys(codes).forEach(function (key) {
      var val = codes[key];
      var style = styles[key] = [];
      style.open = '\u001b[' + val[0] + 'm';
      style.close = '\u001b[' + val[1] + 'm';
    });
  provide("colors/lib/styles", module.exports);
}(global));

// pakmanager:colors/lib/system/supports-colors
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*
    The MIT License (MIT)
    
    Copyright (c) Sindre Sorhus <sindresorhus@gmail.com> (sindresorhus.com)
    
    Permission is hereby granted, free of charge, to any person obtaining a copy
    of this software and associated documentation files (the "Software"), to deal
    in the Software without restriction, including without limitation the rights
    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:
    
    The above copyright notice and this permission notice shall be included in
    all copies or substantial portions of the Software.
    
    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
    THE SOFTWARE.
    
    */
    
    var argv = process.argv;
    
    module.exports = (function () {
      if (argv.indexOf('--no-color') !== -1 ||
        argv.indexOf('--color=false') !== -1) {
        return false;
      }
    
      if (argv.indexOf('--color') !== -1 ||
        argv.indexOf('--color=true') !== -1 ||
        argv.indexOf('--color=always') !== -1) {
        return true;
      }
    
      if (process.stdout && !process.stdout.isTTY) {
        return false;
      }
    
      if (process.platform === 'win32') {
        return true;
      }
    
      if ('COLORTERM' in process.env) {
        return true;
      }
    
      if (process.env.TERM === 'dumb') {
        return false;
      }
    
      if (/^screen|^xterm|^vt100|color|ansi|cygwin|linux/i.test(process.env.TERM)) {
        return true;
      }
    
      return false;
    })();
  provide("colors/lib/system/supports-colors", module.exports);
}(global));

// pakmanager:colors/lib/custom/trap
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  module['exports'] = function runTheTrap (text, options) {
      var result = "";
      text = text || "Run the trap, drop the bass";
      text = text.split('');
      var trap = {
        a: ["\u0040", "\u0104", "\u023a", "\u0245", "\u0394", "\u039b", "\u0414"],
        b: ["\u00df", "\u0181", "\u0243", "\u026e", "\u03b2", "\u0e3f"],
        c: ["\u00a9", "\u023b", "\u03fe"],
        d: ["\u00d0", "\u018a", "\u0500" , "\u0501" ,"\u0502", "\u0503"],
        e: ["\u00cb", "\u0115", "\u018e", "\u0258", "\u03a3", "\u03be", "\u04bc", "\u0a6c"],
        f: ["\u04fa"],
        g: ["\u0262"],
        h: ["\u0126", "\u0195", "\u04a2", "\u04ba", "\u04c7", "\u050a"],
        i: ["\u0f0f"],
        j: ["\u0134"],
        k: ["\u0138", "\u04a0", "\u04c3", "\u051e"],
        l: ["\u0139"],
        m: ["\u028d", "\u04cd", "\u04ce", "\u0520", "\u0521", "\u0d69"],
        n: ["\u00d1", "\u014b", "\u019d", "\u0376", "\u03a0", "\u048a"],
        o: ["\u00d8", "\u00f5", "\u00f8", "\u01fe", "\u0298", "\u047a", "\u05dd", "\u06dd", "\u0e4f"],
        p: ["\u01f7", "\u048e"],
        q: ["\u09cd"],
        r: ["\u00ae", "\u01a6", "\u0210", "\u024c", "\u0280", "\u042f"],
        s: ["\u00a7", "\u03de", "\u03df", "\u03e8"],
        t: ["\u0141", "\u0166", "\u0373"],
        u: ["\u01b1", "\u054d"],
        v: ["\u05d8"],
        w: ["\u0428", "\u0460", "\u047c", "\u0d70"],
        x: ["\u04b2", "\u04fe", "\u04fc", "\u04fd"],
        y: ["\u00a5", "\u04b0", "\u04cb"],
        z: ["\u01b5", "\u0240"]
      }
      text.forEach(function(c){
        c = c.toLowerCase();
        var chars = trap[c] || [" "];
        var rand = Math.floor(Math.random() * chars.length);
        if (typeof trap[c] !== "undefined") {
          result += trap[c][rand];
        } else {
          result += c;
        }
      });
      return result;
    
    }
    
  provide("colors/lib/custom/trap", module.exports);
}(global));

// pakmanager:colors/lib/custom/zalgo
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // please no
    module['exports'] = function zalgo(text, options) {
      text = text || "   he is here   ";
      var soul = {
        "up" : [
          '̍', '̎', '̄', '̅',
          '̿', '̑', '̆', '̐',
          '͒', '͗', '͑', '̇',
          '̈', '̊', '͂', '̓',
          '̈', '͊', '͋', '͌',
          '̃', '̂', '̌', '͐',
          '̀', '́', '̋', '̏',
          '̒', '̓', '̔', '̽',
          '̉', 'ͣ', 'ͤ', 'ͥ',
          'ͦ', 'ͧ', 'ͨ', 'ͩ',
          'ͪ', 'ͫ', 'ͬ', 'ͭ',
          'ͮ', 'ͯ', '̾', '͛',
          '͆', '̚'
        ],
        "down" : [
          '̖', '̗', '̘', '̙',
          '̜', '̝', '̞', '̟',
          '̠', '̤', '̥', '̦',
          '̩', '̪', '̫', '̬',
          '̭', '̮', '̯', '̰',
          '̱', '̲', '̳', '̹',
          '̺', '̻', '̼', 'ͅ',
          '͇', '͈', '͉', '͍',
          '͎', '͓', '͔', '͕',
          '͖', '͙', '͚', '̣'
        ],
        "mid" : [
          '̕', '̛', '̀', '́',
          '͘', '̡', '̢', '̧',
          '̨', '̴', '̵', '̶',
          '͜', '͝', '͞',
          '͟', '͠', '͢', '̸',
          '̷', '͡', ' ҉'
        ]
      },
      all = [].concat(soul.up, soul.down, soul.mid),
      zalgo = {};
    
      function randomNumber(range) {
        var r = Math.floor(Math.random() * range);
        return r;
      }
    
      function is_char(character) {
        var bool = false;
        all.filter(function (i) {
          bool = (i === character);
        });
        return bool;
      }
      
    
      function heComes(text, options) {
        var result = '', counts, l;
        options = options || {};
        options["up"] =   typeof options["up"]   !== 'undefined' ? options["up"]   : true;
        options["mid"] =  typeof options["mid"]  !== 'undefined' ? options["mid"]  : true;
        options["down"] = typeof options["down"] !== 'undefined' ? options["down"] : true;
        options["size"] = typeof options["size"] !== 'undefined' ? options["size"] : "maxi";
        text = text.split('');
        for (l in text) {
          if (is_char(l)) {
            continue;
          }
          result = result + text[l];
          counts = {"up" : 0, "down" : 0, "mid" : 0};
          switch (options.size) {
          case 'mini':
            counts.up = randomNumber(8);
            counts.mid = randomNumber(2);
            counts.down = randomNumber(8);
            break;
          case 'maxi':
            counts.up = randomNumber(16) + 3;
            counts.mid = randomNumber(4) + 1;
            counts.down = randomNumber(64) + 3;
            break;
          default:
            counts.up = randomNumber(8) + 1;
            counts.mid = randomNumber(6) / 2;
            counts.down = randomNumber(8) + 1;
            break;
          }
    
          var arr = ["up", "mid", "down"];
          for (var d in arr) {
            var index = arr[d];
            for (var i = 0 ; i <= counts[index]; i++) {
              if (options[index]) {
                result = result + soul[index][randomNumber(soul[index].length)];
              }
            }
          }
        }
        return result;
      }
      // don't summon him
      return heComes(text, options);
    }
    
  provide("colors/lib/custom/zalgo", module.exports);
}(global));

// pakmanager:colors/lib/maps/america
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var colors =  require('colors/lib/colors');
    
    module['exports'] = (function() {
      return function (letter, i, exploded) {
        if(letter === " ") return letter;
        switch(i%3) {
          case 0: return colors.red(letter);
          case 1: return colors.white(letter)
          case 2: return colors.blue(letter)
        }
      }
    })();
  provide("colors/lib/maps/america", module.exports);
}(global));

// pakmanager:colors/lib/maps/zebra
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var colors =  require('colors/lib/colors');
    
    module['exports'] = function (letter, i, exploded) {
      return i % 2 === 0 ? letter : colors.inverse(letter);
    };
  provide("colors/lib/maps/zebra", module.exports);
}(global));

// pakmanager:colors/lib/maps/rainbow
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var colors =  require('colors/lib/colors');
    
    module['exports'] = (function () {
      var rainbowColors = ['red', 'yellow', 'green', 'blue', 'magenta']; //RoY G BiV
      return function (letter, i, exploded) {
        if (letter === " ") {
          return letter;
        } else {
          return colors[rainbowColors[i++ % rainbowColors.length]](letter);
        }
      };
    })();
    
    
  provide("colors/lib/maps/rainbow", module.exports);
}(global));

// pakmanager:colors/lib/maps/random
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var colors =  require('colors/lib/colors');
    
    module['exports'] = (function () {
      var available = ['underline', 'inverse', 'grey', 'yellow', 'red', 'green', 'blue', 'white', 'cyan', 'magenta'];
      return function(letter, i, exploded) {
        return letter === " " ? letter : colors[available[Math.round(Math.random() * (available.length - 1))]](letter);
      };
    })();
  provide("colors/lib/maps/random", module.exports);
}(global));

// pakmanager:colors/lib/colors
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*
    
    The MIT License (MIT)
    
    Original Library 
      - Copyright (c) Marak Squires
    
    Additional functionality
     - Copyright (c) Sindre Sorhus <sindresorhus@gmail.com> (sindresorhus.com)
    
    Permission is hereby granted, free of charge, to any person obtaining a copy
    of this software and associated documentation files (the "Software"), to deal
    in the Software without restriction, including without limitation the rights
    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:
    
    The above copyright notice and this permission notice shall be included in
    all copies or substantial portions of the Software.
    
    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
    THE SOFTWARE.
    
    */
    
    var colors = {};
    module['exports'] = colors;
    
    colors.themes = {};
    
    var ansiStyles = colors.styles =  require('colors/lib/styles');
    var defineProps = Object.defineProperties;
    
    colors.supportsColor =  require('colors/lib/system/supports-colors');
    
    if (typeof colors.enabled === "undefined") {
      colors.enabled = colors.supportsColor;
    }
    
    colors.stripColors = colors.strip = function(str){
      return ("" + str).replace(/\x1B\[\d+m/g, '');
    };
    
    
    var stylize = colors.stylize = function stylize (str, style) {
      if (!colors.enabled) {
        return str+'';
      }
    
      return ansiStyles[style].open + str + ansiStyles[style].close;
    }
    
    var matchOperatorsRe = /[|\\{}()[\]^$+*?.]/g;
    var escapeStringRegexp = function (str) {
      if (typeof str !== 'string') {
        throw new TypeError('Expected a string');
      }
      return str.replace(matchOperatorsRe,  '\\$&');
    }
    
    function build(_styles) {
      var builder = function builder() {
        return applyStyle.apply(builder, arguments);
      };
      builder._styles = _styles;
      // __proto__ is used because we must return a function, but there is
      // no way to create a function with a different prototype.
      builder.__proto__ = proto;
      return builder;
    }
    
    var styles = (function () {
      var ret = {};
      ansiStyles.grey = ansiStyles.gray;
      Object.keys(ansiStyles).forEach(function (key) {
        ansiStyles[key].closeRe = new RegExp(escapeStringRegexp(ansiStyles[key].close), 'g');
        ret[key] = {
          get: function () {
            return build(this._styles.concat(key));
          }
        };
      });
      return ret;
    })();
    
    var proto = defineProps(function colors() {}, styles);
    
    function applyStyle() {
      var args = arguments;
      var argsLen = args.length;
      var str = argsLen !== 0 && String(arguments[0]);
      if (argsLen > 1) {
        for (var a = 1; a < argsLen; a++) {
          str += ' ' + args[a];
        }
      }
    
      if (!colors.enabled || !str) {
        return str;
      }
    
      var nestedStyles = this._styles;
    
      var i = nestedStyles.length;
      while (i--) {
        var code = ansiStyles[nestedStyles[i]];
        str = code.open + str.replace(code.closeRe, code.open) + code.close;
      }
    
      return str;
    }
    
    function applyTheme (theme) {
      for (var style in theme) {
        (function(style){
          colors[style] = function(str){
            if (typeof theme[style] === 'object'){
              var out = str;
              for (var i in theme[style]){
                out = colors[theme[style][i]](out);
              }
              return out;
            }
            return colors[theme[style]](str);
          };
        })(style)
      }
    }
    
    colors.setTheme = function (theme) {
      if (typeof theme === 'string') {
        try {
          colors.themes[theme] = require(theme);
          applyTheme(colors.themes[theme]);
          return colors.themes[theme];
        } catch (err) {
          console.log(err);
          return err;
        }
      } else {
        applyTheme(theme);
      }
    };
    
    function init() {
      var ret = {};
      Object.keys(styles).forEach(function (name) {
        ret[name] = {
          get: function () {
            return build([name]);
          }
        };
      });
      return ret;
    }
    
    var sequencer = function sequencer (map, str) {
      var exploded = str.split(""), i = 0;
      exploded = exploded.map(map);
      return exploded.join("");
    };
    
    // custom formatter methods
    colors.trap =  require('colors/lib/custom/trap');
    colors.zalgo =  require('colors/lib/custom/zalgo');
    
    // maps
    colors.maps = {};
    colors.maps.america =  require('colors/lib/maps/america');
    colors.maps.zebra =  require('colors/lib/maps/zebra');
    colors.maps.rainbow =  require('colors/lib/maps/rainbow');
    colors.maps.random =  require('colors/lib/maps/random')
    
    for (var map in colors.maps) {
      (function(map){
        colors[map] = function (str) {
          return sequencer(colors.maps[map], str);
        }
      })(map)
    }
    
    defineProps(colors, init());
  provide("colors/lib/colors", module.exports);
}(global));

// pakmanager:colors/lib/extendStringPrototype
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var colors =  require('colors/lib/colors');
    
    module['exports'] = function () {
    
      //
      // Extends prototype of native string object to allow for "foo".red syntax
      //
      var addProperty = function (color, func) {
        String.prototype.__defineGetter__(color, func);
      };
    
      var sequencer = function sequencer (map, str) {
          return function () {
            var exploded = this.split(""), i = 0;
            exploded = exploded.map(map);
            return exploded.join("");
          }
      };
    
      addProperty('strip', function () {
        return colors.strip(this);
      });
    
      addProperty('stripColors', function () {
        return colors.strip(this);
      });
    
      addProperty("trap", function(){
        return colors.trap(this);
      });
    
      addProperty("zalgo", function(){
        return colors.zalgo(this);
      });
    
      addProperty("zebra", function(){
        return colors.zebra(this);
      });
    
      addProperty("rainbow", function(){
        return colors.rainbow(this);
      });
    
      addProperty("random", function(){
        return colors.random(this);
      });
    
      addProperty("america", function(){
        return colors.america(this);
      });
    
      //
      // Iterate through all default styles and colors
      //
      var x = Object.keys(colors.styles);
      x.forEach(function (style) {
        addProperty(style, function () {
          return colors.stylize(this, style);
        });
      });
    
      function applyTheme(theme) {
        //
        // Remark: This is a list of methods that exist
        // on String that you should not overwrite.
        //
        var stringPrototypeBlacklist = [
          '__defineGetter__', '__defineSetter__', '__lookupGetter__', '__lookupSetter__', 'charAt', 'constructor',
          'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable', 'toLocaleString', 'toString', 'valueOf', 'charCodeAt',
          'indexOf', 'lastIndexof', 'length', 'localeCompare', 'match', 'replace', 'search', 'slice', 'split', 'substring',
          'toLocaleLowerCase', 'toLocaleUpperCase', 'toLowerCase', 'toUpperCase', 'trim', 'trimLeft', 'trimRight'
        ];
    
        Object.keys(theme).forEach(function (prop) {
          if (stringPrototypeBlacklist.indexOf(prop) !== -1) {
            console.log('warn: '.red + ('String.prototype' + prop).magenta + ' is probably something you don\'t want to override. Ignoring style name');
          }
          else {
            if (typeof(theme[prop]) === 'string') {
              colors[prop] = colors[theme[prop]];
              addProperty(prop, function () {
                return colors[theme[prop]](this);
              });
            }
            else {
              addProperty(prop, function () {
                var ret = this;
                for (var t = 0; t < theme[prop].length; t++) {
                  ret = colors[theme[prop][t]](ret);
                }
                return ret;
              });
            }
          }
        });
      }
    
      colors.setTheme = function (theme) {
        if (typeof theme === 'string') {
          try {
            colors.themes[theme] = require(theme);
            applyTheme(colors.themes[theme]);
            return colors.themes[theme];
          } catch (err) {
            console.log(err);
            return err;
          }
        } else {
          applyTheme(theme);
        }
      };
    
    };
  provide("colors/lib/extendStringPrototype", module.exports);
}(global));

// pakmanager:colors
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var colors =  require('colors/lib/colors');
    module['exports'] = colors;
    
    // Remark: By default, colors will add style properties to String.prototype
    //
    // If you don't wish to extend String.prototype you can do this instead and native String will not be touched
    //
    //   var colors = require('colors/safe);
    //   colors.red("foo")
    //
    //
     require('colors/lib/extendStringPrototype')();
  provide("colors", module.exports);
}(global));

// pakmanager:csv
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Generated by CoffeeScript 1.7.1
    var generate, parse, stringify, transform;
    
    generate = require('csv-generate');
    
    parse = require('csv-parse');
    
    transform = require('stream-transform');
    
    stringify = require('csv-stringify');
    
    module.exports.generate = generate;
    
    module.exports.parse = parse;
    
    module.exports.transform = transform;
    
    module.exports.stringify = stringify;
    
  provide("csv", module.exports);
}(global));

// pakmanager:cli-table/lib/utils
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  
    /**
     * Repeats a string.
     *
     * @param {String} char(s)
     * @param {Number} number of times
     * @return {String} repeated string
     */
    
    exports.repeat = function (str, times){
      return Array(times + 1).join(str);
    };
    
    /**
     * Pads a string
     *
     * @api public
     */
    
    exports.pad = function (str, len, pad, dir) {
      if (len + 1 >= str.length)
        switch (dir){
          case 'left':
            str = Array(len + 1 - str.length).join(pad) + str;
            break;
    
          case 'both':
            var right = Math.ceil((padlen = len - str.length) / 2);
            var left = padlen - right;
            str = Array(left + 1).join(pad) + str + Array(right + 1).join(pad);
            break;
    
          default:
            str = str + Array(len + 1 - str.length).join(pad);
        };
    
      return str;
    };
    
    /**
     * Truncates a string
     *
     * @api public
     */
    
    exports.truncate = function (str, length, chr){
      chr = chr || '…';
      return str.length >= length ? str.substr(0, length - chr.length) + chr : str;
    };
    
    /**
     * Copies and merges options with defaults.
     *
     * @param {Object} defaults
     * @param {Object} supplied options
     * @return {Object} new (merged) object
     */
    
    function options(defaults, opts) {
      for (var p in opts) {
        if (opts[p] && opts[p].constructor && opts[p].constructor === Object) {
          defaults[p] = defaults[p] || {};
          options(defaults[p], opts[p]);
        } else {
          defaults[p] = opts[p];
        }
      }
      return defaults;
    };
    exports.options = options;
    
    //
    // For consideration of terminal "color" programs like colors.js,
    // which can add ANSI escape color codes to strings,
    // we destyle the ANSI color escape codes for padding calculations.
    //
    // see: http://en.wikipedia.org/wiki/ANSI_escape_code
    //
    exports.strlen = function(str){
      var code = /\u001b\[(?:\d*;){0,5}\d*m/g;
      var stripped = ("" + str).replace(code,'');
      var split = stripped.split("\n");
      return split.reduce(function (memo, s) { return (s.length > memo) ? s.length : memo }, 0);
    }
    
  provide("cli-table/lib/utils", module.exports);
}(global));

// pakmanager:cli-table
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  
    /**
     * Module dependencies.
     */
    
    var colors = require('colors/safe')
      , utils =  require('cli-table/lib/utils')
      , repeat = utils.repeat
      , truncate = utils.truncate
      , pad = utils.pad;
    
    /**
     * Table constructor
     *
     * @param {Object} options
     * @api public
     */
    
    function Table (options){
      this.options = utils.options({
          chars: {
              'top': '─'
            , 'top-mid': '┬'
            , 'top-left': '┌'
            , 'top-right': '┐'
            , 'bottom': '─'
            , 'bottom-mid': '┴'
            , 'bottom-left': '└'
            , 'bottom-right': '┘'
            , 'left': '│'
            , 'left-mid': '├'
            , 'mid': '─'
            , 'mid-mid': '┼'
            , 'right': '│'
            , 'right-mid': '┤'
            , 'middle': '│'
          }
        , truncate: '…'
        , colWidths: []
        , colAligns: []
        , style: {
              'padding-left': 1
            , 'padding-right': 1
            , head: ['red']
            , border: ['grey']
            , compact : false
          }
        , head: []
      }, options);
    };
    
    /**
     * Inherit from Array.
     */
    
    Table.prototype.__proto__ = Array.prototype;
    
    /**
     * Width getter
     *
     * @return {Number} width
     * @api public
     */
    
    Table.prototype.__defineGetter__('width', function (){
      var str = this.toString().split("\n");
      if (str.length) return str[0].length;
      return 0;
    });
    
    /**
     * Render to a string.
     *
     * @return {String} table representation
     * @api public
     */
    
    Table.prototype.render
    Table.prototype.toString = function (){
      var ret = ''
        , options = this.options
        , style = options.style
        , head = options.head
        , chars = options.chars
        , truncater = options.truncate
          , colWidths = options.colWidths || new Array(this.head.length)
          , totalWidth = 0;
    
        if (!head.length && !this.length) return '';
    
        if (!colWidths.length){
          var all_rows = this.slice(0);
          if (head.length) { all_rows = all_rows.concat([head]) };
    
          all_rows.forEach(function(cells){
            // horizontal (arrays)
            if (typeof cells === 'object' && cells.length) {
              extractColumnWidths(cells);
    
            // vertical (objects)
            } else {
              var header_cell = Object.keys(cells)[0]
                , value_cell = cells[header_cell];
    
              colWidths[0] = Math.max(colWidths[0] || 0, get_width(header_cell) || 0);
    
              // cross (objects w/ array values)
              if (typeof value_cell === 'object' && value_cell.length) {
                extractColumnWidths(value_cell, 1);
              } else {
                colWidths[1] = Math.max(colWidths[1] || 0, get_width(value_cell) || 0);
              }
            }
        });
      };
    
      totalWidth = (colWidths.length == 1 ? colWidths[0] : colWidths.reduce(
        function (a, b){
          return a + b
        })) + colWidths.length + 1;
    
      function extractColumnWidths(arr, offset) {
        var offset = offset || 0;
        arr.forEach(function(cell, i){
          colWidths[i + offset] = Math.max(colWidths[i + offset] || 0, get_width(cell) || 0);
        });
      };
    
      function get_width(obj) {
        return typeof obj == 'object' && obj.width != undefined
             ? obj.width
             : ((typeof obj == 'object' ? utils.strlen(obj.text) : utils.strlen(obj)) + (style['padding-left'] || 0) + (style['padding-right'] || 0))
      }
    
      // draws a line
      function line (line, left, right, intersection){
        var width = 0
          , line =
              left
            + repeat(line, totalWidth - 2)
            + right;
    
        colWidths.forEach(function (w, i){
          if (i == colWidths.length - 1) return;
          width += w + 1;
          line = line.substr(0, width) + intersection + line.substr(width + 1);
        });
    
        return applyStyles(options.style.border, line);
      };
    
      // draws the top line
      function lineTop (){
        var l = line(chars.top
                   , chars['top-left'] || chars.top
                   , chars['top-right'] ||  chars.top
                   , chars['top-mid']);
        if (l)
          ret += l + "\n";
      };
    
      function generateRow (items, style) {
        var cells = []
          , max_height = 0;
    
        // prepare vertical and cross table data
        if (!Array.isArray(items) && typeof items === "object") {
          var key = Object.keys(items)[0]
            , value = items[key]
            , first_cell_head = true;
    
          if (Array.isArray(value)) {
            items = value;
            items.unshift(key);
          } else {
            items = [key, value];
          }
        }
    
        // transform array of item strings into structure of cells
        items.forEach(function (item, i) {
          var contents = item.toString().split("\n").reduce(function (memo, l) {
            memo.push(string(l, i));
            return memo;
          }, [])
    
          var height = contents.length;
          if (height > max_height) { max_height = height };
    
          cells.push({ contents: contents , height: height });
        });
    
        // transform vertical cells into horizontal lines
        var lines = new Array(max_height);
        cells.forEach(function (cell, i) {
          cell.contents.forEach(function (line, j) {
            if (!lines[j]) { lines[j] = [] };
            if (style || (first_cell_head && i === 0 && options.style.head)) {
              line = applyStyles(options.style.head, line)
            }
    
            lines[j].push(line);
          });
    
          // populate empty lines in cell
          for (var j = cell.height, l = max_height; j < l; j++) {
            if (!lines[j]) { lines[j] = [] };
            lines[j].push(string('', i));
          }
        });
        var ret = "";
        lines.forEach(function (line, index) {
          if (ret.length > 0) {
            ret += "\n" + applyStyles(options.style.border, chars.left);
          }
    
          ret += line.join(applyStyles(options.style.border, chars.middle)) + applyStyles(options.style.border, chars.right);
        });
    
        return applyStyles(options.style.border, chars.left) + ret;
      };
    
      function applyStyles(styles, subject) {
        if (!subject)
          return '';
        styles.forEach(function(style) {
          subject = colors[style](subject);
        });
        return subject;
      };
    
      // renders a string, by padding it or truncating it
      function string (str, index){
        var str = String(typeof str == 'object' && str.text ? str.text : str)
          , length = utils.strlen(str)
          , width = colWidths[index]
              - (style['padding-left'] || 0)
              - (style['padding-right'] || 0)
          , align = options.colAligns[index] || 'left';
    
        return repeat(' ', style['padding-left'] || 0)
             + (length == width ? str :
                 (length < width
                  ? pad(str, ( width + (str.length - length) ), ' ', align == 'left' ? 'right' :
                      (align == 'middle' ? 'both' : 'left'))
                  : (truncater ? truncate(str, width, truncater) : str))
               )
             + repeat(' ', style['padding-right'] || 0);
      };
    
      if (head.length){
        lineTop();
    
        ret += generateRow(head, style.head) + "\n"
      }
    
      if (this.length)
        this.forEach(function (cells, i){
          if (!head.length && i == 0)
            lineTop();
          else {
            if (!style.compact || i<(!!head.length) ?1:0 || cells.length == 0){
              var l = line(chars.mid
                         , chars['left-mid']
                         , chars['right-mid']
                         , chars['mid-mid']);
              if (l)
                ret += l + "\n"
            }
          }
    
          if (cells.hasOwnProperty("length") && !cells.length) {
            return
          } else {
            ret += generateRow(cells) + "\n";
          };
        });
    
      var l = line(chars.bottom
                 , chars['bottom-left'] || chars.bottom
                 , chars['bottom-right'] || chars.bottom
                 , chars['bottom-mid']);
      if (l)
        ret += l;
      else
        // trim the last '\n' if we didn't add the bottom decoration
        ret = ret.slice(0, -1);
    
      return ret;
    };
    
    /**
     * Module exports.
     */
    
    module.exports = Table;
    
    module.exports.version = '0.0.1';
    
  provide("cli-table", module.exports);
}(global));

// pakmanager:grunt-speedgun
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*
     * grunt-speedgun
     * https://github.com/lggarrison/grunt-speedgun
     *
     * Copyright (c) 2015 Lacy Garrison
     * Licensed under the MIT license.
     */
    
    'use strict';
    
    module.exports = function(grunt) {
    
        // Project configuration.
        grunt.initConfig({
    
            jshint: {
                all: [
                    'Gruntfile.js',
                    'tasks/*.js',
                ],
                options: {
                    jshintrc: '.jshintrc'
                }
            },
    
            speedgun: {
                default_options: {
                    options: {
                        url: 'http://localhost',
                        port: 4000,
                        limit: 5
                    }
                },
                custom_options: {
                    options: {
                        url: 'http://localhost',
                        port: 4001,
                        limit: 5
                    }
                },
                custom_options2: {
                    options: {
                        url: 'http://bloomberg.com'
                    }
                }
            },
    
        });
    
        grunt.loadTasks('tasks');
    
        grunt.loadNpmTasks('grunt-contrib-jshint');
        grunt.loadNpmTasks('grunt-contrib-clean');
    
        grunt.registerTask('test', ['speedgun']);
    
        grunt.registerTask('default ', ['jshint', 'test']);
    
    };
    
  provide("grunt-speedgun", module.exports);
}(global));